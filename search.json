[
  {
    "objectID": "API/utils.html",
    "href": "API/utils.html",
    "title": "utils",
    "section": "",
    "text": "source\n\nalign2mut\n\n align2mut (align)\n\nConverts a sequence alignment result from Bio.pairwise2.Align.globalms into a list of mutations. Positions are those of the alignment.\n\nseqA = \"ATCCCGGCAGC\"\nseqB = \"ATCCACGGTCAGC\"\nalign=pairwise2.align.globalms(seqA,seqB, 2, -1, -1, -.5, one_alignment_only=True)[0]\nalign2mut(align)\n\n[('-', 4, 'A'), ('-', 8, 'T')]\n\n\n\nsource\n\n\nmut_rix\n\n mut_rix (mutations)\n\nReindexes the positions of the mutations to go from their position in the sequence alignment to their position in the original sequence.\n\nseqA = \"ATCCCGGCAGC\"\nseqB = \"ATCCACGGTCAGC\"\nalign=pairwise2.align.globalms(seqA,seqB, 2, -1, -1, -.5, one_alignment_only=True)[0]\nprint(format_alignment(*align))\n\nmutations=align2mut(align) \nprint(\"Output of align2mut:\")\nprint(mutations)\n\nprint(\"Output of mut_rix:\")\nprint(mut_rix(mutations))\n\nATCC-CGG-CAGC\n|||| ||| ||||\nATCCACGGTCAGC\n  Score=20\n\nOutput of align2mut:\n[('-', 4, 'A'), ('-', 8, 'T')]\nOutput of mut_rix:\n[('-', 4, 'A'), ('-', 7, 'T')]\n\n\n\nsource\n\n\nget_mutations\n\n get_mutations (seqA, seqB, match=2, mismatch=-1, gap_open=-1,\n                gap_extend=-0.5)\n\nAligns two sequences and returns a genotype string. The string is a comma separated list of mutations.\n\nseqA = \"ATCCGGCAGCAGGTCGTGAGC\"\nseqB = \"ATCCACGGTCAGCACGTCGTGGC\"\nalign=pairwise2.align.globalms(seqA,seqB, 2, -1, -1, -.5, one_alignment_only=True)[0]\nprint(format_alignment(*align))\n\nget_mutations(seqA,seqB)\n\nATC--CGG-CAGCAGGTCGTGAGC\n|||  ||| |||||.|||||| ||\nATCCACGGTCAGCACGTCGTG-GC\n  Score=33.5\n\n\n\n[('-', 3, 'C'), ('-', 3, 'A'), ('-', 6, 'T'), ('G', 11, 'C'), ('A', 18, '-')]\n\n\n\nsource\n\n\nget_mutations_noalign\n\n get_mutations_noalign (seqA, seqB)\n\nReturns a genotype string. The string is a comma separated list of mutations.\n\nget_mutations_noalign(\"AGCTATGG\",\"AGCTCTGG\")\n\n[('A', '4', 'C')]\n\n\n\nsource\n\n\nmut_to_str\n\n mut_to_str (mutations:list)\n\nConverts list of mutations to a comma separated string\n\nmut_to_str([('-', 3, 'C'), ('-', 3, 'A'), ('-', 6, 'T'), ('G', 11, 'C'), ('A', 18, '-')])\n\n'-3C,-3A,-6T,G11C,A18-'\n\n\n\nsource\n\n\nstr_to_mut\n\n str_to_mut (gen:str)\n\nConverts genotype string to a list of mutations\n\nassert(str_to_mut('')==[])\nstr_to_mut('-4A,-7T,G12C')\n\n[['-', 4, 'A'], ['-', 7, 'T'], ['G', 12, 'C']]\n\n\n\nsource\n\n\ngenstr_to_seq\n\n genstr_to_seq (genstr, refseq)\n\n\ngenstr='-3C,-3A,-6T,G11C,A18-'\ngenstr_to_seq(genstr,seqA)\n\n'ATCCACGGTCAGCACGTCGTGGC'\n\n\n\ns=\"AGCGAGC\"\nprint(len(s)%3)\ns[:-(len(s)%3)]\n\n1\n\n\n'AGCGAG'\n\n\n\nsource\n\n\nreverse_complement\n\n reverse_complement (dna)\n\n\nsource\n\n\nget_prot_mut\n\n get_prot_mut (genstr, refseq, frame=0, ori=1)\n\n\nseqA = \"AGCGCTATGCTGCGCGCGTACTGCCGCTAGCTATGCTCAGGCCGATATATGCGAGCA\"\nseqB = \"AGCGCTATGCTGCGCGCGAAAACCCGCTAGCTATGCTCAGGTCGATATATGCGAGCA\"\ngenstr=mut_to_str(get_mutations(seqA,seqB,gap_open=-5))\nprint(genstr)\nget_prot_mut(genstr,seqA,frame=1)\n\nT18A,C20A,T21A,G22C,C41T\n\n\n'T6K,A7P,A13V'\n\n\n\ngenstr='A61G,-63T,A79T'\nrefseq='CGCCTTGGTAGCCATCTTCAGTTCCAGTGTTTGCTTCAAATACTAAGTATTTGTGGCCTTTATCTTCTACGTAGTGAGGATCTCTCAGCGTATGGTTGTCGCCTGAGCTGTAGTTGCCTTCATCGATGAACTGCTGTAC'\nori=-1\nframe=0\nget_prot_mut(genstr,refseq,frame=frame,ori=ori)\n\n'D19E,D25E,K26Q,G27R,H28P,K29Q,Y30I,V32S,F33I,E34*,A35S,N36K,T37H,G38W,T39N,E40*,D41R,G42W,Y43L,Q44P,G45R'\n\n\n\ngenstr='A61G,A79T'\nrefseq='CGCCTTGGTAGCCATCTTCAGTTCCAGTGTTTGCTTCAAATACTAAGTATTTGTGGCCTTTATCTTCTACGTAGTGAGGATCTCTCAGCGTATGGTTGTCGCCTGAGCTGTAGTTGCCTTCATCGATGAACTGCTGTAC'\nori=-1\nframe=0\nget_prot_mut(genstr,refseq,frame=frame,ori=ori)\n\n'D19E'\n\n\n\nsource\n\n\nparse_genotypes\n\n parse_genotypes (genotypes_file)\n\n\nfrom dgrec.example_data import get_example_data_dir\n\n\ndata_path=get_example_data_dir()\ngen_list=parse_genotypes(os.path.join(data_path,\"sacB_genotypes.csv\"))\nfor g,n in itertools.islice(gen_list,30,40):\n    print(n,\"\\t\",g)\n\n20   A72G,A79G\n19   A72G,A79T,A91G\n17   T67G,A91G\n17   A76G,A79T\n17   A68C,A72G\n17   A111G\n16   A68G,A91G\n16   A86G,A91T\n15   A72G,A91T\n15   A79G,A86G\n\n\n\nsource\n\n\nget_aa_mut_list\n\n get_aa_mut_list (gen_list, refseq, frame=0, ori=1)\n\n\nread_ref_file=\"sacB_ref.fasta\"\nrefseq=next(SeqIO.parse(os.path.join(data_path,read_ref_file),\"fasta\"))\nrefseq=str(refseq.seq)\naa_mut_list=get_aa_mut_list(gen_list,refseq,ori=-1)\naa_mut_list[:10]\n\n[('', 43341),\n ('Y22H', 351),\n ('H15Q', 277),\n ('D19E', 246),\n ('L17P', 200),\n ('V23A', 162),\n ('S11P', 117),\n ('D25E', 113),\n ('D19E,Y22H', 75),\n ('T16P', 61)]\n\n\n\nsource\n\n\ndownsample_fastq_gz\n\n downsample_fastq_gz (input_file, output_file, num_reads=10000)\n\n*Downsamples a compressed FASTQ file to the specified number of reads.\nArgs: input_file (str): Path to the input FASTQ.gz file. output_file (str): Path to the output FASTQ.gz file. num_reads (int, optional): Number of reads to keep. Defaults to 10000.*\n\ninput_file=os.path.join(data_path,\"sacB_example.fastq.gz\")\noutput_file=\"sacB_example_downsampled.fastq.gz\"\ndownsample_fastq_gz(input_file, output_file, num_reads=100)\n\n\nsource\n\n\nget_basename_without_extension\n\n get_basename_without_extension (file_path)\n\n*Extracts the basename of a file without the extension.\nArgs: file_path (str): The path to the file.\nReturns: str: The basename of the file without the extension.*\n\n# Example usage\nfile_path = \"C:/Users/John/Documents/my_file.txt\"\nbasename_without_extension = get_basename_without_extension(file_path)\nprint(basename_without_extension)  # Output: my_file\n\nmy_file\n\n\n\nsource\n\n\npickle_save\n\n pickle_save (data_in, file_name_out)\n\n\nsource\n\n\npickle_load\n\n pickle_load (file_name_in)\n\n\nsource\n\n\nmake_dgr_oligos\n\n make_dgr_oligos (target:str, split_number:int)\n\nSplit the TR target into the input number and then generates the oligos to order\n\n\n\n\nType\nDetails\n\n\n\n\ntarget\nstr\nTR DNA\n\n\nsplit_number\nint\nNumber of desired splits\n\n\n\n\ntarget='CCTCAGATACAAGCCGGCATAAATAATAACATATTCTATGACCATGATAATAGTGTAGGTGCAAACGCCAACGCTAAAAACACTGGAACCATGAACGGTAATACTGCAGGGACGAATATAGCCAAAACTTCT'\nmake_dgr_oligos(target,4)\n\n['ATAACCTCAGATACAAGCCGGCATAAATAATAACA',\n 'AATATGTTATTATTTATGCCGGCTTGTATCTGAGG',\n 'TATTCTATGACCATGATAATAGTGTAGGTGCAA',\n 'GCGTTTGCACCTACACTATTATCATGGTCATAG',\n 'ACGCCAACGCTAAAAACACTGGAACCATGAACG',\n 'TTACCGTTCATGGTTCCAGTGTTTTTAGCGTTG',\n 'GTAATACTGCAGGGACGAATATAGCCAAAACTTCT',\n 'CAGAAGAAGTTTTGGCTATATTCGTCCCTGCAGTA']\n\n\n\nsource\n\n\nreverse_comp_geno_list\n\n reverse_comp_geno_list (geno_list:list, ref_seq:str)\n\n\n\n\n\nType\nDetails\n\n\n\n\ngeno_list\nlist\nList of genotypes\n\n\nref_seq\nstr\nstring of the template sequence\n\n\n\n\nsource\n\n\nremove_position\n\n remove_position (geno, pos_list)\n\n\nsource\n\n\nremove_position_list\n\n remove_position_list (geno_list, pos_list)\n\n\nref_genome='AACGTATACGGCGGAATATTTGCCGAATGCCGTGTGGACGTAAGCGTGAACGTCAGGATCACGTTTCCCCGACCCGCTGGCATGTCAACAATACGGGAGAACACCTGTACCGCCTCGTTCGCCGCGC'\ngeno_list_test=[('T19C', 176012),\n ('T19C,T64A,T65A', 169),\n ('T19C,G36T', 40),\n ('T19C,T58G,T63A,T64G', 4),\n ('T19C,A42C', 14),\n ('T19C,T63G', 13),\n ('T19C,T52A,T64A,T65A', 19),\n ('T19C,A41C,A57C,T58C', 1),\n ('T19C,T52A', 94),\n ('T19C,T64A,T65G', 214),\n ('T19C,T63A,T64C,T65A', 2),\n ('T19C,A49C,T64C,T91C', 2),\n ('T19C,T32C,T52C,T64A,T65G,T84C,T91A', 1),\n ('T19C,T82C,T84A', 8),\n ('T19C,T64C', 308),\n ('T19C,T40C,G43A,T58A,A71C,T91C', 1),\n ('T52A,T77C', 1),\n ('T19C,T52C,T58A', 9),\n ('T20C,-52C,T58C,A71C,T77C', 1),\n ('T19C,G70T', 110),\n ('T19C,T32C,T65C,T82C', 1),\n ('T19C,T32C,T46C', 4),\n ('T19C,T32C,A41C,A49C,T64A,T65G', 1),\n ('T19C,T64A', 115),\n ('T19C,T58C', 68)]\n\ngeno_list_test=remove_position_list(geno_list_test,[19])\nreverse_comp_geno_list(geno_list_test,ref_genome)\n\n[('', 176012),\n ('A61T,A62T', 169),\n ('C90A', 40),\n ('A62C,A63T,A68C', 4),\n ('T84G', 14),\n ('A63C', 13),\n ('A61T,A62T,A74T', 19),\n ('A68G,T69G,T85G', 1),\n ('A74T', 94),\n ('A61C,A62T', 214),\n ('A61T,A62G,A63T', 2),\n ('A35G,A62G,T77G', 2),\n ('A35T,A42G,A61C,A62T,A74G,A94G', 1),\n ('A42T,A44G', 8),\n ('A62G', 308),\n ('A35G,T55G,A68T,C83T,A86G', 1),\n ('A49G,A74T', 1),\n ('A68T,A74G', 9),\n ('A49G,T55G,A68G,-74G,A106G', 1),\n ('C56A', 110),\n ('A44G,A61G,A94G', 1),\n ('A80G,A94G', 4),\n ('A61C,A62T,T77G,T85G,A94G', 1),\n ('A62T', 115),\n ('A68G', 68)]",
    "crumbs": [
      "API",
      "utils"
    ]
  },
  {
    "objectID": "API/genotypes_paired.html",
    "href": "API/genotypes_paired.html",
    "title": "genotypes_paired",
    "section": "",
    "text": "source\n\nget_UMI_genotype_paired\n\n get_UMI_genotype_paired (fastq_path_fwd:str, fastq_path_rev:str,\n                          ref_seq:str, fwd_span:tuple, rev_span:tuple,\n                          fwd_ref_read_size:int=None,\n                          rev_ref_read_size:int=None,\n                          require_perfect_pair_agreement:bool=True,\n                          umi_size_fwd:int=10, umi_size_rev:int=0,\n                          quality_threshold:int=30, ignore_pos:list=[],\n                          N=None, **kwargs)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfastq_path_fwd\nstr\n\npath to the input fastq file reading the ref_seq in the forward orientation\n\n\nfastq_path_rev\nstr\n\npath to the input fastq file reading the ref_seq in the reverse orientation\n\n\nref_seq\nstr\n\nsequence of the reference amplicon\n\n\nfwd_span\ntuple\n\nspan of the ref_seq that is read in the forward orientation format: (start, end)\n\n\nrev_span\ntuple\n\nspan of the ref_seq that is read in the reverse orientation format: (start, end)\n\n\nfwd_ref_read_size\nint\nNone\nnumber of nucleotides in the fwd read expected to align to the ref_seq. If None the whole read will be used.\n\n\nrev_ref_read_size\nint\nNone\nnumber of nucleotides in the rev read expected to align to the ref_seq. If None the whole read will be used.\n\n\nrequire_perfect_pair_agreement\nbool\nTrue\nif True only pairs of reads that perfectly agree on the sequence within the common span will be used. If False the fwd sequence will be used. Will be set to False by default if there is no overlap.\n\n\numi_size_fwd\nint\n10\nnumber of nucleotides at the begining of the fwd read that will be used as the UMI\n\n\numi_size_rev\nint\n0\nnumber of nucleotides at the begining of the rev read that will be used as the UMI (if both are provided the umi will be the concatenation of both)\n\n\nquality_threshold\nint\n30\nthreshold value used to filter out reads of poor average quality. Both reads have to pass the threshold.\n\n\nignore_pos\nlist\n[]\nlist of positions that are ignored in the genotype\n\n\nN\nNoneType\nNone\nnumber of reads to consider (useful to get a quick view of the data without going through the whole fastq files). If None the whole data will be used.\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\nReturns\ndict\n\nalignment parameters can be passed here (match, mismatch, gap_open, gap_extend)\n\n\n\n\nfastq_path_fwd=os.path.join(data_path,\"paired_example1_R2.fastq.gz\")\nfastq_path_rev=os.path.join(data_path,\"paired_example1_R1.fastq.gz\")\n\n\nread_ref_file=\"sacB_ref.fasta\"\nref=next(SeqIO.parse(os.path.join(data_path,read_ref_file),\"fasta\"))\nref_seq=\"GAGGAGACGGTGACCTGGGTCCCCTGGCCCCAGTTGTTGAAGTCATACCCTTAGGCACCATAGTATCCAGACGCACAGTAGTACAAGGCAGTGTCCTCAGGTTTCAGGCTGTTCATTTGCAGATACACCGTGTTCTTGGCGTTGTCTTGGG\"\n\nUMI_gencounter = get_UMI_genotype_paired(fastq_path_fwd, \n                                         fastq_path_rev, \n                                         ref_seq, \n                                         fwd_span=(0,150), \n                                         rev_span=(0,0),\n                                         umi_size_fwd=0,\n                                         umi_size_rev=10,\n                                         N=10,\n                                         ignore_pos=[0,1,2,150,151])\n\nfor umi in itertools.islice(UMI_gencounter,20):\n    print(umi, list(UMI_gencounter[umi].items()))\n\nn reads:    10\nn_reads pass filter:    10\nn_reads aligned:    10\nn_pairs agree:  0\nNumber of UMIs: 10\nMedian number of reads per UMI: 1.0\nGGACGCGATA [('T50A,T51G', 1)]\nGCTGTATGTT [('T50A,T51G', 1)]\nGGGAAGGCGT [('', 1)]\nGGCGACAGTG [('', 1)]\nCCATGTCGGG [('', 1)]\nCNGATGTTTG [('T33G,T34A,T51G', 1)]\nGTCACACCAC [('T33C,T34C,T36C,T50A', 1)]\nCCAGACTGTT [('', 1)]\nCAGGGTTTAT [('T50A,T51G', 1)]\nATGGGTACGG [('T130A', 1)]\n\n\n\nsource\n\n\nget_genotypes_paired\n\n get_genotypes_paired (fastq_path_fwd:str, fastq_path_rev:str,\n                       ref_seq:str, fwd_span:tuple, rev_span:tuple,\n                       fwd_ref_read_size:int=None,\n                       rev_ref_read_size:int=None,\n                       require_perfect_pair_agreement:bool=True,\n                       umi_size_fwd:int=10, umi_size_rev:int=0,\n                       quality_threshold:int=30, ignore_pos:list=[],\n                       reads_per_umi_thr:int=0, save_umi_data:str=None,\n                       N=None, **kwargs)\n\nPutting things together in a single wrapper function that takes the fastq as input and returns the list of genotypes.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfastq_path_fwd\nstr\n\npath to the input fastq file reading the ref_seq in the forward orientation\n\n\nfastq_path_rev\nstr\n\npath to the input fastq file reading the ref_seq in the reverse orientation\n\n\nref_seq\nstr\n\nsequence of the reference amplicon\n\n\nfwd_span\ntuple\n\nspan of the ref_seq that is read in the forward orientation format: (start, end)\n\n\nrev_span\ntuple\n\nspan of the ref_seq that is read in the reverse orientation format: (start, end)\n\n\nfwd_ref_read_size\nint\nNone\nnumber of nucleotides in the fwd read expected to align to the ref_seq. If None the whole read will be used.\n\n\nrev_ref_read_size\nint\nNone\nnumber of nucleotides in the rev read expected to align to the ref_seq. If None the whole read will be used.\n\n\nrequire_perfect_pair_agreement\nbool\nTrue\nif True only pairs of reads that perfectly agree on the sequence within the common span will be used. If False the fwd sequence will be used. Will be set to False by default if there is no overlap.\n\n\numi_size_fwd\nint\n10\nnumber of nucleotides at the begining of the fwd read that will be used as the UMI\n\n\numi_size_rev\nint\n0\nnumber of nucleotides at the begining of the rev read that will be used as the UMI (if both are provided the umi will be the concatenation of both)\n\n\nquality_threshold\nint\n30\nthreshold value used to filter out reads of poor average quality\n\n\nignore_pos\nlist\n[]\nlist of positions that are ignored in the genotype\n\n\nreads_per_umi_thr\nint\n0\nminimum number of reads required to take a UMI into account. Using a number &gt;2 enables to perform error correction for UMIs with multiple reads.\n\n\nsave_umi_data\nstr\nNone\npath to the csv file where to save the details of the genotypes reads for each UMI. If None the data isn’t saved.\n\n\nN\nNoneType\nNone\nnumber of reads to consider (useful to get a quick view of the data without going through the whole fastq files). If None the whole data will be used.\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\n\n\ngen_list = get_genotypes_paired(fastq_path_fwd, \n                        fastq_path_rev, \n                        ref_seq, \n                        fwd_span=(0,150), \n                        rev_span=(0,0),\n                        umi_size_fwd=0,\n                        umi_size_rev=10,\n                        ignore_pos=[0,1,150,151],\n                        N=100,\n                        save_umi_data=\"test.csv\")\nfor g in gen_list[:20]:\n    print(f\"{g[1]}\\t{g[0]}\")\n\nn reads:    100\nn_reads pass filter:    96\nn_reads aligned:    94\nn_pairs agree:  0\nNumber of UMIs: 85\nMedian number of reads per UMI: 1.0\nNumber of genotypes: 12\n49  \n23  T50A,T51G\n2   T33G,T34A,T51G\n2   T33C,T34C,T36C,T50A\n2   T37C,T42C,T45A,T50C,T51C\n1   T130A\n1   A52C\n1   G8A\n1   T51C\n1   A52C,G131C\n1   G69A\n1   T37C,T42C,T45A,T50C,T51C,T146A",
    "crumbs": [
      "API",
      "genotypes_paired"
    ]
  },
  {
    "objectID": "API/plotting.html",
    "href": "API/plotting.html",
    "title": "plotting",
    "section": "",
    "text": "read_ref_file=\"sacB_ref.fasta\"\nref=next(SeqIO.parse(os.path.join(data_path,read_ref_file),\"fasta\"))\n\n\n#read_ref_file=\"\\\\sacB_ref.fasta\"\n#ref=next(SeqIO.parse(data_path+read_ref_file,'fasta'))\n\nref_seq=str(ref.seq)\ngen_list=parse_genotypes(os.path.join(data_path,\"sacB_genotypes.csv\"))\n\n\n# read_ref_file_paul='/home/prochett/DGRec/dgrec/example_data/sacB_ref.fasta'\n# ref_paul=next(SeqIO.parse(os.path.join(data_path,read_ref_file_paul),\"fasta\"))\n\n# ref_seq=str(ref_paul.seq)\n# gen_list=[]\n# with open(os.path.join(data_path,\"/home/prochett/DGRec/dgrec/example_data/sacB_genotypes.csv\"),\"r\") as handle: \n#     reader = csv.reader(handle, delimiter='\\t')\n#     for row in reader:\n#         gen_list.append((row[0],int(row[1])))\n\n\nsource\n\nplot_mutations\n\n plot_mutations (gen_list:list, ref_seq:str, sample_name:str=None,\n                 plot_range:Union[tuple,list]=None,\n                 TR_range:Union[tuple,list]=None, ax=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ngen_list\nlist\n\nlist of genotypes. Each genotype is a tuple: (string representation of the genotype, number of molecules)\n\n\nref_seq\nstr\n\nreference sequence\n\n\nsample_name\nstr\nNone\nsample name\n\n\nplot_range\nUnion\nNone\nlimits the plot to the specified range\n\n\nTR_range\nUnion\nNone\nwhen specified creates a shaded box highlighting the position of the TR\n\n\nax\nNoneType\nNone\nmakes it possible to pass matplotlib axis to easily configure and save plots\n\n\n\n\nsource\n\n\nplot_mutations_percentage\n\n plot_mutations_percentage (gen_list:list, ref_seq:str,\n                            sample_name:str=None,\n                            plot_range:Union[tuple,list]=None,\n                            TR_range:Union[tuple,list]=None,\n                            rev_comp=False, ax=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ngen_list\nlist\n\nlist of genotypes. Each genotype is a tuple: (string representation of the genotype, number of molecules)\n\n\nref_seq\nstr\n\nreference sequence\n\n\nsample_name\nstr\nNone\nsample name\n\n\nplot_range\nUnion\nNone\nlimits the plot to the specified range\n\n\nTR_range\nUnion\nNone\nwhen specified creates a shaded box highlighting the position of the TR\n\n\nrev_comp\nbool\nFalse\n\n\n\nax\nNoneType\nNone\nmakes it possible to pass matplotlib axis to easily configure and save plots\n\n\n\n\nax = plot_mutations(gen_list, ref_seq, sample_name=\"sacB\", plot_range=[0,139], TR_range=[50,119])\n\n\n\n\n\n\n\n\n\nax,mut_perc=plot_mutations_percentage(gen_list, ref_seq, sample_name=\"sacB\", plot_range=[0,139], TR_range=[50,119])\nplt.show\nprint(mut_perc)\n\n9.73\n\n\n\n\n\n\n\n\n\n\nax = plot_mutations_percentage(gen_list, ref_seq, sample_name=\"sacB\", plot_range=[0,139], TR_range=[20,89],rev_comp=True)\n\n\n\n\n\n\n\n\n\nsource\n\n\nplot_mutations_percentage_protein\n\n plot_mutations_percentage_protein (aa_mut_list, ref_prot,\n                                    plot_range=None, ax=None)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\naa_mut_list\n\n\nlist of genotypes. Each genotype is a tuple: (string representation of the genotype, number of molecules)\n\n\nref_prot\n\n\nreference sequence\n\n\nplot_range\nNoneType\nNone\nlimits the plot to the specified range\n\n\nax\nNoneType\nNone\n\n\n\n\n\naa_mut_list=get_aa_mut_list(gen_list,ref_seq,ori=-1) #the sacB gene is in reverse complement orientation compared to the VR so ori=-1 is needed\naa_mut_list[:10]\n\n[('', 43341),\n ('Y22H', 351),\n ('H15Q', 277),\n ('D19E', 246),\n ('L17P', 200),\n ('V23A', 162),\n ('S11P', 117),\n ('D25E', 113),\n ('D19E,Y22H', 75),\n ('T16P', 61)]\n\n\n\nref_prot=Seq(ref_seq).reverse_complement()[:-1].translate() #the sacB gene is in reverse complement orientation compared to the VR\n\nfig, ax = plt.subplots(1, 1, figsize=(20, 5))\nplot_mutations_percentage_protein(aa_mut_list, ref_prot, ax=ax)\nplt.show()\n\n/tmp/ipykernel_1816/3434536392.py:11: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed two minor releases later. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap(obj)`` instead.\n  colormap = cm.get_cmap(colormap_name, num_colors)",
    "crumbs": [
      "API",
      "plotting"
    ]
  },
  {
    "objectID": "DGRec data analysis/mutation_distribution.html",
    "href": "DGRec data analysis/mutation_distribution.html",
    "title": "Mutations distribution",
    "section": "",
    "text": "We explore here the distribution of A, T, G or C mutated among the mutated molecules sequenced in a DGRec experiment.\nWe start from a list of genotypes and the number molecules found for each:\n\n\nCode\nfrom dgrec.utils import parse_genotypes, str_to_mut\nfrom dgrec.example_data import get_example_data_dir\nfrom Bio import SeqIO\nimport os\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n#Importing a list of genotypes with the number of molecules detected for each genotype\ndata_path=get_example_data_dir()\ngen_list=parse_genotypes(os.path.join(data_path,\"sacB_genotypes.csv\"))\n\ngen_list[0:50:5]\n\n\n[('', 42572),\n ('A76G', 112),\n ('T67G', 67),\n ('T90G', 41),\n ('A76G,A91G', 29),\n ('A72G,A79T', 22),\n ('A72G,A79G', 20),\n ('A111G', 17),\n ('A79T,A91T', 15),\n ('A79C,A91G', 13)]\n\n\nWe then plot how many of each base is found mutated among mutated molecules\n\n\nCode\n#converting genotype strings to lists\nmutations=[[str_to_mut(gen[0]),gen[1]] for gen in gen_list[1:]] \n\n#Counting the number genotypes with c bases mutated for each possible base\nbases=\"ATGC\"\nnN_mut=dict([(b,np.zeros(8)) for b in bases])\nfor g,n in mutations:\n    mutated_bases=np.array(list(zip(*g))[0])\n    for b in bases:\n        c=np.sum(mutated_bases==b) #number of mutated bases that are adenines\n        nN_mut[b][c]+=n\n\nfig, axes = plt.subplots(1,4,figsize=(16,4), sharey=True)\naxes[0].set_ylabel(\"number of molecules\")\nfor i,b in enumerate(bases):\n    axes[i].bar(range(8),nN_mut[b])\n    axes[i].set_title(b)\n    axes[i].set_xticks(range(8))\n    \n\n# Adjust layout\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "DGRec data analysis",
      "Mutations distribution"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "dgrec",
    "section": "",
    "text": "Read the doc: https://dbikard.github.io/dgrec/",
    "crumbs": [
      "dgrec"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "dgrec",
    "section": "Install",
    "text": "Install\npip install git+https://github.com/dbikard/dgrec.git",
    "crumbs": [
      "dgrec"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "dgrec",
    "section": "How to use",
    "text": "How to use\n\nCommand line interface\n\nSingle reads\ndgrec genotypes fastq_path reference_path -o genotypes.csv\n\n\nUsage: dgrec genotypes [OPTIONS] FASTQ REF\n\nOptions:\n  -u, --umi_size INTEGER          Number of nucleotides at the begining of the\n                                  read that will be used as the UMI\n  -q, --quality_threshold INTEGER\n                                  threshold value used to filter out reads of\n                                  poor average quality\n  -i, --ignore_pos LIST           list of positions that are ignored in the\n                                  genotype, e.g. [0,1,149,150]\n  -r, --reads_per_umi_thr INTEGER\n                                  minimum number of reads required to take a\n                                  UMI into account. Using a number &gt;2 enables\n                                  to perform error correction for UMIs with\n                                  multiple reads\n  -s, --save_umi_data TEXT        path to a csv file to save the details of\n                                  the genotypes reads for each UMI. If None\n                                  the data isn't saved.\n  -o, --output TEXT               output file path\n  --help                          Show this message and exit.\n\n\n\n\nPaired reads\ndgrec genotypes_paired fwd_fastq_path rev_fastq_path reference_path --fwd_span 0 150 --rev_span 30 150 -o genotypes.csv\n\n\nUsage: dgrec genotypes_paired [OPTIONS] FASTQ_FWD FASTQ_REV REF\n\n  Calls dgrec.genotypes_paired.get_genotypes_paired\n\nOptions:\n  --fwd_span &lt;INTEGER INTEGER&gt;...\n                                  Span of the reference sequence read in the\n                                  forward orientation format: start end\n                                  [required]\n  --rev_span &lt;INTEGER INTEGER&gt;...\n                                  Span of the reference sequence read in the\n                                  reverse orientation format: start end\n                                  [required]\n  -p, --require_perfect_pair_agreement\n                                  Require perfect pair agreement for genotype\n                                  calling (default: True).                  If\n                                  set to False, the forward sequence will be\n                                  used in case of disagreement.\n  -u1, --umi_size_fwd INTEGER     Number of nucleotides at the beginning of\n                                  the fwd read that will be used as the UMI\n                                  (default: 10)\n  -u2, --umi_size_rev INTEGER     Number of nucleotides at the beginning of\n                                  the rev read that will be used as the UMI\n                                  (default: 0)\n  -q, --quality_threshold INTEGER\n                                  Threshold value used to filter out reads of\n                                  poor average quality (default: 30)\n  -i, --ignore_pos LIST           List of positions that are ignored in the\n                                  genotype (default: [])\n  -r, --reads_per_umi_thr INTEGER\n                                  Minimum number of reads required to take a\n                                  UMI into account (default: 0).\n                                  Using a number &gt;2 enables to perform error\n                                  correction for UMIs with multiple reads\n  -s, --save_umi_data TEXT        Path to a csv file to save the details of\n                                  the genotypes reads for each UMI. If None\n                                  the data isn't saved (default: None)\n  -n INTEGER                      Number of reads to use. If None all the\n                                  reads are used (default: None)\n  -o, --output TEXT               Output file path\n  --help                          Show this message and exit.\n\n\n\n\n\nIn python\n\nimport dgrec\n\n\nfrom Bio import SeqIO\nimport os\n\n#Getting the path to the fastq file\nfastq_file=\"sacB_example.fastq.gz\"\nfastq_path=os.path.join(data_path,fastq_file)\n\n#Getting the reference sequence for the amplicon\nread_ref_file=\"sacB_ref.fasta\"\nref=next(SeqIO.parse(os.path.join(data_path,read_ref_file),\"fasta\"))\nref_seq=str(ref.seq)\n\n#Generating a list of genotypes sorted by the number of UMIs that are read for each genotype\ngen_list = dgrec.get_genotypes(fastq_path, ref_seq, ignore_pos=[0,1,2,138,139,140,141])\n\n#Printing the top results\nfor g in gen_list[:20]:\n    print(f\"{g[1]}\\t{g[0]}\")\n\nn reads:    1000\nn_reads pass filter:    847\nn_reads aligned:    824\nNumber of UMIs: 814\nMedian number of reads per UMI: 1.0\nNumber of genotypes: 123\n675 \n3   C56A\n3   A76G\n3   A91G\n3   A91T\n2   C69T\n2   T122A\n2   A91C\n2   A105G\n2   C116A\n2   T60A\n2   T59A\n2   A68G\n2   T134A\n1   A61G,-63T,A76T,A91T\n1   A79T,A91G\n1   A61G,A72G,A76G,A79T\n1   T108A,G127T,G132T\n1   A48T,A86G\n1   A61T,A68T,A72G,A79C,A91G\n\n\n\nfig = dgrec.plot_mutations(gen_list, ref_seq, sample_name=\"sacB\", TR_range=[50,119])",
    "crumbs": [
      "dgrec"
    ]
  },
  {
    "objectID": "API/cli.html",
    "href": "API/cli.html",
    "title": "Command line interface",
    "section": "",
    "text": "&lt;Group dgrec&gt; (*args:Any, **kwargs:Any)\n\n\n\n\n\n\n &lt;Command genotypes&gt; (*args:Any, **kwargs:Any)\n\n\n\n\n\n\n &lt;Command genotypes_paired&gt; (*args:Any, **kwargs:Any)\n\nCalls dgrec.genotypes_paired.get_genotypes_paired",
    "crumbs": [
      "API",
      "Command line interface"
    ]
  },
  {
    "objectID": "API/analysis.html",
    "href": "API/analysis.html",
    "title": "analysis",
    "section": "",
    "text": "from dgrec.example_data import get_example_data_dir\n\n\nsource\n\nmut_rate\n\n mut_rate (gen_list:list, ran:tuple, ref_seq:str)\n\nComputes the mutation rate per base within the specified range. The rate can be computed for specific bases using the base_restriction argument.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ngen_list\nlist\na genotype list with the number of molecules detected\n\n\nran\ntuple\nthe position range in which to compute the mutation rate. If None the rate is computed for the full sequence.\n\n\nref_seq\nstr\nreference sequence\n\n\n\n\ndata_path=get_example_data_dir()\ngen_list=parse_genotypes(os.path.join(data_path,\"sacB_genotypes.csv\"))\n\nread_ref_file=\"sacB_ref.fasta\"\nref=next(SeqIO.parse(os.path.join(data_path,read_ref_file),\"fasta\"))\nref_seq=str(ref.seq)\n\n#showing a few example lines\nfor g,n in gen_list[1:200:20]:\n    print(n,\"\\t\",g)\n\n279      A91G\n28   A68C\n15   A72G,A79T,A91T\n10   A61G,A72G\n6    A61G,A68G\n6    A68G,A76G,A91G\n5    A61T,A79G\n4    A86T\n4    A72G,A76G,A86G,A91T\n3    A61T,A76G,A91G\n\n\n\nTR_range=(50,119)\nbefore_TR_range=(5,50)\nmut_rate_TR=mut_rate(gen_list,TR_range,ref_seq)\nfor b in mut_rate_TR:\n    print(f\"Mutation rate in VR at {b} positions: {mut_rate_TR[b]:.1e}\")\n\nmut_rate_outside_TR=mut_rate(gen_list,before_TR_range,ref_seq)\nfor b in mut_rate_outside_TR:\n    print(f\"Mutation rate outside VR at {b} positions: {mut_rate_outside_TR[b]:.1e}\")\n\nMutation rate in VR at A positions: 1.9e-02\nMutation rate in VR at T positions: 9.9e-04\nMutation rate in VR at G positions: 1.1e-04\nMutation rate in VR at C positions: 2.2e-04\nMutation rate in VR at all positions: 2.9e-03\nMutation rate outside VR at A positions: 2.1e-05\nMutation rate outside VR at T positions: 4.8e-05\nMutation rate outside VR at G positions: 1.8e-04\nMutation rate outside VR at C positions: 5.9e-05\nMutation rate outside VR at all positions: 6.7e-05",
    "crumbs": [
      "API",
      "analysis"
    ]
  },
  {
    "objectID": "API/genotypes.html",
    "href": "API/genotypes.html",
    "title": "genotypes",
    "section": "",
    "text": "source\n\nget_UMI_genotype\n\n get_UMI_genotype (fastq_path:str, ref_seq:str, umi_size:int=10,\n                   ref_read_size:int=None, quality_threshold:int=30,\n                   ignore_pos:list=[], **kwargs)\n\nTakes as input a fastq_file of single read amplicon sequencing, and a reference amplicon sequence. Returns a dictionnary containing as keys UMIs and as values a Counter of all genotype strings read for that UMI.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfastq_path\nstr\n\npath to the input fastq file\n\n\nref_seq\nstr\n\nsequence of the reference amplicon\n\n\numi_size\nint\n10\nnumber of nucleotides at the begining of the read that will be used as the UMI\n\n\nref_read_size\nint\nNone\nnumber of nucleotides in the read expected to align to the ref_seq. If None the whole read will be used.\n\n\nquality_threshold\nint\n30\nthreshold value used to filter out reads of poor average quality\n\n\nignore_pos\nlist\n[]\nlist of positions that are ignored in the genotype\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\nReturns\ndict\n\nalignment parameters can be passed here (match, mismatch, gap_open, gap_extend)\n\n\n\n\nfastq_file=\"sacB_example.fastq.gz\"\nfastq_path=os.path.join(data_path,fastq_file)\n\nread_ref_file=\"sacB_ref.fasta\"\nref=next(SeqIO.parse(os.path.join(data_path,read_ref_file),\"fasta\"))\nref_seq=str(ref.seq)\n\nUMI_gencounter = get_UMI_genotype(fastq_path, ref_seq, ignore_pos=[0,1,2,138,139,140,141], gap_open=-5)\n\nfor umi in itertools.islice(UMI_gencounter,20):\n    print(umi, list(UMI_gencounter[umi].items()))\n\nn reads:    1000\nn_reads pass filter:    847\nn_reads aligned:    824\nNumber of UMIs: 814\nMedian number of reads per UMI: 1.0\nGCATANCTCA [('A61G,-63T,A76T,A91T', 1)]\nCGCATNTATA [('', 1)]\nCCTTGNAGTA [('', 1)]\nGGCGCNAGAA [('', 1)]\nTCTCTTGTGA [('', 1)]\nATTACAGAAT [('', 1)]\nCTTTTACTAT [('', 1)]\nTCAAAGTTTT [('A79T,A91G', 1)]\nTTAGCTCATA [('', 1)]\nTCATAATGTA [('', 1)]\nATGTGCGGAT [('', 1)]\nTGTGTTTATA [('', 1)]\nCCATACATCC [('', 1)]\nAGGGACGTTT [('A61G,A72G,A76G,A79T', 1)]\nGTGTAATAGC [('', 1)]\nATGTCTTTTA [('', 1)]\nTATCGGTAGT [('', 1)]\nGTCGGGGGGG [('', 1)]\nAAGTGGCACA [('', 1)]\nAATAGAACCT [('T108A,G127T,G132T', 1)]\n\n\n\nsource\n\n\ncorrect_UMI_genotypes\n\n correct_UMI_genotypes (UMI_gencounter:dict, reads_per_umi_thr=2)\n\nKeeps only the genotype with the most reads for each UMI. Returns a dictionary with UMIs as keys and a tuple as value: (genotype string, number of reads)\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nUMI_gencounter\ndict\n\nthe output of the get_UMI_genotype function\n\n\nreads_per_umi_thr\nint\n2\nonly assign a genotype to a UMI if we have reads_per_umi_thr reads for that genotype or more\n\n\nReturns\ndict\n\n\n\n\n\n\ncorrect_UMI_genotypes(UMI_gencounter)\n\n{'CTCCGGGGAG': '',\n 'TGCTTGAGTG': 'A79T',\n 'AGGGCGGGCT': '',\n 'ATTTCTGTTT': '',\n 'TGGGGGGGCT': '',\n 'GATTGGTAGA': '',\n 'GAACTCTAGT': '',\n 'TAACTAATCG': 'A79G,A86G,A91G'}\n\n\n\nsource\n\n\ngenotype_UMI_counter\n\n genotype_UMI_counter (UMI_gen_dict)\n\nTakes as input the output of correct_UMI_genotypes() and returns a list of genotypes sorted by the number of UMIs detected corresponding that each genotype.\n\nUMI_gen_dict=correct_UMI_genotypes(UMI_gencounter, reads_per_umi_thr=0)\ngen_list = genotype_UMI_counter(UMI_gen_dict)\nfor g in gen_list[:20]:\n    print(f\"{g[1]}\\t{g[0]}\")\n\n675 \n3   C56A\n3   A76G\n3   A91G\n3   A91T\n2   C69T\n2   T122A\n2   A91C\n2   A105G\n2   C116A\n2   T60A\n2   T59A\n2   A68G\n2   T134A\n1   A61G,-63T,A76T,A91T\n1   A79T,A91G\n1   A61G,A72G,A76G,A79T\n1   T108A,G127T,G132T\n1   A48T,A86G\n1   A61T,A68T,A72G,A79C,A91G\n\n\n\nsource\n\n\nget_genotypes\n\n get_genotypes (fastq_path:str, ref_seq:str, umi_size:int=10,\n                ref_read_size:int=None, quality_threshold:int=30,\n                ignore_pos:list=[], reads_per_umi_thr:int=0,\n                save_umi_data:str=None, **kwargs)\n\nPutting things together in a single wrapper function that takes the fastq as input and returns the list of genotypes.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfastq_path\nstr\n\npath to the input fastq file\n\n\nref_seq\nstr\n\nsequence of the reference amplicon\n\n\numi_size\nint\n10\nnumber of nucleotides at the begining of the read that will be used as the UMI\n\n\nref_read_size\nint\nNone\nnumber of nucleotides in the read expected to align to the ref_seq. If None the whole read will be used.\n\n\nquality_threshold\nint\n30\nthreshold value used to filter out reads of poor average quality\n\n\nignore_pos\nlist\n[]\nlist of positions that are ignored in the genotype\n\n\nreads_per_umi_thr\nint\n0\nminimum number of reads required to take a UMI into account. Using a number &gt;2 enables to perform error correction for UMIs with multiple reads.\n\n\nsave_umi_data\nstr\nNone\npath to the csv file where to save the details of the genotypes reads for each UMI. If None the data isn’t saved.\n\n\nkwargs\nVAR_KEYWORD\n\n\n\n\n\n\nfastq_file=\"sacB_example.fastq.gz\"\nfastq_path=os.path.join(data_path,fastq_file)\nread_ref_file=\"sacB_ref.fasta\"\nref=next(SeqIO.parse(os.path.join(data_path,read_ref_file),\"fasta\"))\nref_seq=str(ref.seq)\ngen_list = get_genotypes(fastq_path, ref_seq, \n                         ignore_pos=[0,1,2,138,139,140,141],\n                         gap_open=-4, \n                         save_umi_data=\"test.csv\")\nfor g in gen_list[:20]:\n    print(f\"{g[1]}\\t{g[0]}\")\n\nn reads:    1000\nn_reads pass filter:    847\nn_reads aligned:    824\nNumber of UMIs: 814\nMedian number of reads per UMI: 1.0\nNumber of genotypes: 123\n675 \n3   C56A\n3   A76G\n3   A91G\n3   A91T\n2   C69T\n2   T122A\n2   A91C\n2   A105G\n2   C116A\n2   T60A\n2   T59A\n2   A68G\n2   T134A\n1   A61G,-63T,A76T,A91T\n1   A79T,A91G\n1   A61G,A72G,A76G,A79T\n1   T108A,G127T,G132T\n1   A48T,A86G\n1   A61T,A68T,A72G,A79C,A91G",
    "crumbs": [
      "API",
      "genotypes"
    ]
  }
]