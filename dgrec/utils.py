# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/API/07_utils.ipynb.

# %% auto 0
__all__ = ['align2mut', 'mut_rix', 'get_mutations', 'get_mutations_noalign', 'mut_to_str', 'str_to_mut', 'genstr_to_seq',
           'reverse_complement', 'get_prot_mut', 'parse_genotypes', 'get_aa_mut_list', 'downsample_fastq_gz',
           'get_basename_without_extension', 'pickle_save', 'pickle_load', 'make_dgr_oligos', 'reverse_comp_geno_list',
           'remove_position', 'remove_position_list', 'save_alignment_to_svg']

# %% ../nbs/API/07_utils.ipynb 2
import gzip
import itertools
import os
import csv
from . import pairwise2
from .pairwise2 import format_alignment
from Bio.Align import PairwiseAligner
from Bio.Seq import Seq
from Bio import SeqIO
from typing import List, Optional
import svgwrite
from Bio import pairwise2
from Bio.Seq import Seq
from Bio.Data import CodonTable

# %% ../nbs/API/07_utils.ipynb 3
def align2mut(align):
    """Converts a sequence alignment result from Bio.pairwise2.Align.globalms into a list of mutations.
    Positions are those of the alignment."""
    res=[]
    for i in range(align.end):
        if align.seqA[i]!=align.seqB[i]:
            mut=(align.seqA[i],i,align.seqB[i])
            res.append(mut)
    return res

# %% ../nbs/API/07_utils.ipynb 5
def mut_rix(mutations):
    """Reindexes the positions of the mutations to go from 
    their position in the sequence alignment to their position in the original sequence."""
    ph=0
    res_rix=[]
    for mut in mutations:
        rix=mut[1]+ph
        res_rix.append((mut[0],rix,mut[2]))
        if mut[0]=='-':
            ph-=1
            
    return res_rix

# %% ../nbs/API/07_utils.ipynb 7
def get_mutations(seqA,seqB, match=2, mismatch=-1, gap_open=-1, gap_extend=-.5):
    """Aligns two sequences and returns a genotype string.
    The string is a comma separated list of mutations.
    """
    align=pairwise2.align.globalms(seqA,seqB, match, mismatch, gap_open, gap_extend, one_alignment_only=True)[0]
    mutations=align2mut(align) 
    mutations=mut_rix(mutations)
    return mutations

# %% ../nbs/API/07_utils.ipynb 9
def get_mutations_noalign(seqA,seqB):
    """Returns a genotype string.
    The string is a comma separated list of mutations.
    """
    assert(len(seqA)==len(seqB))
    mutations=[]
    for i in range(len(seqA)):
        if seqA[i]!=seqB[i]:
            mutations.append((seqA[i],str(i),seqB[i]))
    return mutations

# %% ../nbs/API/07_utils.ipynb 15
def mut_to_str(mutations: list):
    """Converts list of mutations to a comma separated string"""
    mut_str_list=[''.join(map(str,mut)) for mut in mutations]
    mut_str=','.join(mut_str_list)
    return mut_str

# %% ../nbs/API/07_utils.ipynb 17
def str_to_mut(gen: str):
    """Converts genotype string to a list of mutations"""
    
    mutations=[]
    if gen=="":
        return mutations
    else:
        g=gen.split(',')
        for mut in g:
            mut_from=mut[0]
            ix=int(mut[1:-1])
            mut_to=mut[-1]
            mutations.append([mut_from,ix,mut_to])

        return mutations

# %% ../nbs/API/07_utils.ipynb 19
def genstr_to_seq(genstr,refseq):
    j=0
    seq=''
    for mut in str_to_mut(genstr):
        tb, i, qb = mut
        seq+=refseq[j:i]
        if tb=="-":
            seq+=qb
            j=i
        elif qb=="-":
            j=i+1
            pass
        else:
            seq+=qb
            j=i+1

    seq+=refseq[j:]

    return seq

# %% ../nbs/API/07_utils.ipynb 23
def reverse_complement(dna):
    # Dictionary to hold the complement of each base
    complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C','-': '-','N': 'N'}
    
    # Reverse the DNA string
    reversed_dna = dna[::-1]
    
    # Get the complement for each base in the reversed string
    reverse_complement_dna = ''.join(complement[base] for base in reversed_dna)
    
    return reverse_complement_dna



# %% ../nbs/API/07_utils.ipynb 24
def get_prot_mut(genstr,refseq,frame=0,ori=1):
    mut_seq=genstr_to_seq(genstr,refseq)
    if ori==-1:
        refseq=reverse_complement(refseq)
        mut_seq=reverse_complement(mut_seq)

    cut_mut=((len(mut_seq)-frame)%3)
    if cut_mut:
        mut_seq_inframe=mut_seq[frame:-cut_mut]
    else:
        mut_seq_inframe=mut_seq[frame:]

    cut_ref=((len(refseq)-frame)%3)
    if cut_ref:
        refseq_inframe=refseq[frame:-cut_ref]
    else:
        refseq_inframe=refseq[frame:]

    mut_prot=Seq(mut_seq_inframe).translate()
    ref_prot=Seq(refseq_inframe).translate()
    L=min(len(mut_prot),len(ref_prot))
    mut_prot=mut_prot[:L]
    ref_prot=ref_prot[:L]
    return mut_to_str(get_mutations_noalign(ref_prot,mut_prot))


# %% ../nbs/API/07_utils.ipynb 28
def parse_genotypes(genotypes_file):
    gen_list=[]
    with open(genotypes_file,"r") as handle: 
        reader = csv.reader(handle, delimiter='\t')
        for row in reader:
            gen_list.append((row[0],int(row[1])))
    return gen_list

# %% ../nbs/API/07_utils.ipynb 31
def get_aa_mut_list(gen_list,refseq, frame=0, ori=1):
    amino_mut_dic={}
    for gen, n in gen_list:
        if "-" not in gen: #excludes insertion or deletions as they will lead to frameshifts
            if "N" not in gen:  #exclue Ns
                mut=get_prot_mut(gen, refseq, frame=frame, ori=ori)
                if mut in amino_mut_dic:
                    amino_mut_dic[mut]+=n
                else:
                    amino_mut_dic[mut]=n
    aa_mut_list=list(amino_mut_dic.items())
    aa_mut_list=sorted(aa_mut_list,key=lambda x: x[1],reverse=True)
    return aa_mut_list


# %% ../nbs/API/07_utils.ipynb 33
def downsample_fastq_gz(input_file, output_file, num_reads=10000):
    """Downsamples a compressed FASTQ file to the specified number of reads.

    Args:
        input_file (str): Path to the input FASTQ.gz file.
        output_file (str): Path to the output FASTQ.gz file.
        num_reads (int, optional): Number of reads to keep. Defaults to 10000.
    """

    with gzip.open(input_file, 'rb') as infile, gzip.open(output_file, 'wb') as outfile:
        lines = itertools.islice(infile, num_reads * 4)  # Read 4 lines (1 read) at a time
        for line in lines:
            outfile.write(line)

# %% ../nbs/API/07_utils.ipynb 35
def get_basename_without_extension(file_path):
    """
    Extracts the basename of a file without the extension.

    Args:
        file_path (str): The path to the file.

    Returns:
        str: The basename of the file without the extension.
    """

    basename = os.path.basename(file_path)
    if '.' in basename:
        # Split at the last dot to remove the extension
        return basename.rsplit('.', 1)[0]
    else:
        # No extension, return the whole filename
        return basename

# %% ../nbs/API/07_utils.ipynb 39
def pickle_save(data_in,file_name_out):
    pickle_out = open(file_name_out,"wb")
    pickle.dump(data_in, pickle_out)
    pickle_out.close()
    


# %% ../nbs/API/07_utils.ipynb 40
def pickle_load(file_name_in):
    pickle_in = open(file_name_in,"rb")
    data_out = pickle.load(pickle_in)
    return data_out

# %% ../nbs/API/07_utils.ipynb 41
def make_dgr_oligos(target:str #TR DNA
                    ,split_number:int #Number of desired splits
                    ):
    "Split the TR target into the input number and then generates the oligos to order"
    bad_overhangs=['AATT', 'ATAT', 'TATA', 'TTAA', 'ACGT', 'CATG', 'CTAG', 'GATC', 'GTAC', 'TCGA', 'TGCA', 'CCGG', 'CGCG', 'GCGC', 'GGCC']
    target=target.upper()
    split=len(target)//split_number
    overhang_list=[]
    split_k_list=[]
    forward_list=[]
    reverse_list=[]
    full_list=[]


    
    for k in range(1,split_number):
        split_k=k*split
        overhang = target[split_k-2:split_k+2]
        
        while overhang in bad_overhangs+['ATAA','TCAG']:
            if split_k%2 == 0:
                split_k += 1
                print('+1')
            elif split_k%2 == 1:
                split_k += -1
                print('-1')
            overhang = target[split_k-2:split_k+2]
        overhang_list.append(overhang)
        split_k_list.append(split_k)

    forward_list.append('ATAA'+target[:split_k_list[0]-2])
    reverse_list.append(reverse_complement(target[:split_k_list[0]+2]))

    for j in range (len(split_k_list)-1):
        forward_list.append(target[split_k_list[j]-2:split_k_list[j+1]-2])
        reverse_list.append(reverse_complement(target[split_k_list[j]+2:split_k_list[j+1]+2]))


    forward_list.append(target[split_k_list[-1]-2:])
    reverse_list.append('CAGA'+reverse_complement(target[split_k_list[-1]+2:]))

    for i in range(split_number):
        full_list.append(forward_list[i])
        full_list.append(reverse_list[i])
            
    return(full_list)

# %% ../nbs/API/07_utils.ipynb 43
def reverse_comp_geno_list(geno_list:list # List of genotypes
                           ,ref_seq:str #string of the template sequence
                           ):
    l=len(ref_seq)
    gene_rev_dic={}
    for geno in geno_list:
        if geno[0]!='':
            mut_list=geno[0].split(',')
            umi_count=geno[1]
            rev_mut_list=[]
            for mut in mut_list:
                old_base=mut[0]
                new_base=mut[-1]
                position=int(mut[1:-1])
                rev_mut=reverse_complement(old_base)+str(l-position-1)+reverse_complement(new_base)
                rev_mut_list.append((rev_mut))
            revgen=','.join(rev_mut_list[::-1])
            if revgen in gene_rev_dic:
                gene_rev_dic[revgen]+=umi_count
            else:
                gene_rev_dic[revgen]=umi_count

        else:
            gene_rev_dic['']=geno[1]

    geno_list_rev = list(gene_rev_dic.items())
    return geno_list_rev


# %% ../nbs/API/07_utils.ipynb 44
def remove_position(geno,pos_list):
    mut_split=geno.split(',')
    new_geno=[]
    for mut in mut_split:
        if int(mut[1:-1]) not in pos_list:
            new_geno.append(mut)
    return ','.join(new_geno)



# %% ../nbs/API/07_utils.ipynb 45
def remove_position_list(geno_list,pos_list):
    new_geno_list=[]
    for k in geno_list:
        geno_k=k[0]
        count_k=k[1]
        # print(geno_k)
        if geno_k!='':
            new_geno_k=remove_position(geno_k,pos_list)
            new_geno_list.append((new_geno_k,count_k))
        else:
            new_geno_k=geno_k
            new_geno_list.append((new_geno_k,count_k))
    return new_geno_list

# %% ../nbs/API/07_utils.ipynb 48
def save_alignment_to_svg(
    reference: str, #The reference DNA sequence
    sequences: List[str], #A list of mutated DNA sequences
    labels: Optional[List[str]] = None, #Labels for the mutated sequences. Defaults to "Mutated X"
    filename: str = "alignment.svg" #Output SVG file name. Defaults to alignement.svg
) -> None:
    """
    Saves DNA and amino acid sequence alignments to an SVG file.
    
    - Aligns input sequences to a reference (both at DNA and protein levels).
    - Highlights mismatches and codon structures.
    - Colors bases and amino acids by biochemical properties.
    """
    if labels is None:
        labels = [f"Mutated {i+1}" for i in range(len(sequences))]
    
    # Translate DNA to amino acids
    ref_aa = translate_dna(reference)
    seqs_aa = [translate_dna(seq) for seq in sequences]
    
    # Perform pairwise alignments (DNA and protein levels)
    alignments = [pairwise2.align.localms(reference, seq, 2, 0, -3, -2, one_alignment_only=True)[0] for seq in sequences]
    aa_alignments = [pairwise2.align.localms(ref_aa, seq_aa, 2, 0, -2, -1, one_alignment_only=True)[0] for seq_aa in seqs_aa]
    
    # SVG drawing settings
    dwg = svgwrite.Drawing(filename, profile='tiny', size=(len(reference) * 17 + 160, 70 + len(sequences) * 40))
    font_size, line_spacing = 14, 20
    codon_spacing, aa_spacing = 15, 45
    x_start, y_start = 10, 30
    
    # Define color mappings
    base_colors = {"A": "#FF9999", "T": "#99FF99", "G": "#FFFF99", "C": "#99FFFF", '-': '#FFFFFF'}
    aa_colors = {"A": "#6693BA", "I": "#6693BA", "L": "#6693BA", "V": "#6693BA", "P": "#6693BA", "G": "#6693BA",
                 "F": "#AB88A9", "W": "#AB88A9", "Y": "#AB88A9", "D": "#D2A392", "E": "#D2A392", "H": "#E0C08B",
                 "K": "#E0C08B", "R": "#E0C08B", "S": "#6DABA9", "T": "#6DABA9", "C": "#6DABA9", "M": "#6DABA9",
                 "N": "#6DABA9", "Q": "#6DABA9", "-": "#FFFFFF", "*": "#BB888C"}
    
    def add_colored_text(dwg, text, x, y, color="black", bgcolor=None):
        """Adds colored rectangles with text to the SVG."""
        if bgcolor:
            dwg.add(dwg.rect(insert=(x-2, y-14), size=(12, 18), fill=bgcolor, stroke="none"))
        dwg.add(dwg.text(text, insert=(x, y), font_size=font_size, fill=color, font_family="Courier"))
    
    # DNA Alignment Section
    y_offset = y_start
    ref_aligned, *_ = alignments[0]
    x_offset = x_start
    add_colored_text(dwg, "Reference:", x_offset, y_offset)
    x_offset += 150
    codon_positions = []
    
    for i, base in enumerate(ref_aligned):
        bgcolor = base_colors.get(base, None)
        add_colored_text(dwg, base, x_offset, y_offset, bgcolor=bgcolor)
        x_offset += codon_spacing
        if (i+1) % 3 == 0:
            x_offset += 5
            codon_positions.append(x_offset - codon_spacing)
    y_offset += line_spacing
    
    # Amino Acid Reference Alignment
    ref_aa_aligned, *_ = aa_alignments[0]
    x_offset = x_start
    add_colored_text(dwg, "AA Ref:", x_offset, y_offset)
    x_offset += 150
    for j, aa in enumerate(ref_aa_aligned):
        add_colored_text(dwg, aa, codon_positions[j]-20, y_offset, bgcolor=aa_colors.get(aa, "#FFFFFF"))
    y_offset += line_spacing
    
    # Process Each Mutated Sequence
    for i, (alignment, label) in enumerate(zip(alignments, labels)):
        ref_seq, seq_aligned, *_ = alignment
        x_offset = x_start
        add_colored_text(dwg, f"{label}:", x_offset, y_offset)
        x_offset += 150
        
        count = 0
        for ref_base, seq_base in zip(ref_aligned, seq_aligned):
            bgcolor = base_colors.get(seq_base, None) if ref_base != seq_base and seq_base != "-" else "#FFFFFF"
            add_colored_text(dwg, seq_base, x_offset, y_offset, bgcolor=bgcolor)
            x_offset += codon_spacing
            if (count+1) % 3 == 0:
                x_offset += 5
            count += 1
        y_offset += line_spacing
        
        # Amino Acid Alignment for Mutated Sequence
        ref_aa_seq, aa_seq_aligned, *_ = aa_alignments[i]
        x_offset = x_start + 150
        
        for j, (ref_aa, seq_aa) in enumerate(zip(ref_aa_aligned, aa_seq_aligned)):
            bgcolor = aa_colors.get(seq_aa, None) if ref_aa != seq_aa and seq_aa != "-" else "#FFFFFF"
            add_colored_text(dwg, seq_aa, codon_positions[j]-20, y_offset, bgcolor=bgcolor)
        y_offset += line_spacing
    
    # Save to file
    dwg.save()
    print(f"Alignment saved to {filename}")
