# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/API/04_encoding.ipynb.

# %% auto 0
__all__ = ['encode_tr_list']

# %% ../nbs/API/04_encoding.ipynb 3
import ViennaRNA as RNA
import numpy as np
from tqdm import tqdm

# %% ../nbs/API/04_encoding.ipynb 4
def encode_tr_list(list_TRs: list # A list of DNA sequences (strings) to encode.
    ,feat=1                     ):
    """
    Encodes a list of TR sequences. If feat is 1, uses only the single feature model, if 2 uses the 2 features model.
    """
    Avd='aagggcaggctgggaaATAA'.upper()
    Sp='tctgtgcccatcaccttcttgcatggctctgccaacgctacggcttggcgggctggcctttcctcaataggtggtcagccggttctgtcctgcttcggcgaacacgttacacggttcggcaaaacgtcgattactgaaaatggaaaggcggggccgacttc'.upper()

    # Initialize an empty list to store the encoded features
    new_features_encoded = []

    # Iterate through each DNA sequence in the list
    for TR in list_TRs:
        features = []

        # Base folding energy of TR alone
        fc_base = RNA.fold_compound(TR)
        _, e_tr = fc_base.pf()
    
        fc_sp = RNA.fold_compound(TR + Sp[:30])
        _, e_tr_sp = fc_sp.pf()
        features.append(e_tr_sp - e_tr)
        new_features_encoded.append(features)
        if feat==2:
            fc_avd_sp = RNA.fold_compound(Avd+TR + Sp[:15])
            _, e_avd_sp = fc_avd_sp.pf()
            features.append(e_avd_sp - e_tr)
            new_features_encoded.append(features)

    # Convert the list of encoded features into a NumPy array
    return np.array(new_features_encoded)
